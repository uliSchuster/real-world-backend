{-# LANGUAGE Arrows #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE NoImplicitPrelude #-}

-- |
-- Module      :  <File name or $Header$ to be replaced automatically>
-- Description :  Location where events can take place.
-- Copyright   :  (c) 2020, Real-World Haskell Study Group
-- License     :  Apache License 2.0
-- Maintainer  :  real-world-study-group@ugsmail.mailworks.org
-- Stability   :  unstable
-- Lang. Ext.  :  Arrows - Required by Opaleye
--             :  FlexibleInstances - Required by Opaleye
--             :  MultiParamTypeClasses - Required by Opaleye
--             :  TemplateHaskell - Lets Opaleye generate the mapping function
--             :  NoImplicitPrelude - Use RIO instead
--
-- Database interface for the "user" relation, using the Opaleye mapper and
-- typesafe query and data manipulation DSL.
-- See https://github.com/tomjaguarpaw/haskell-opaleye and the (outdated)
-- tutorial here: https://www.haskelltutorials.com/opaleye/index.html
module Persistence.Users
  ( User,
    getAllUsers,
  )
where

import qualified Control.Arrow ()
import qualified Data.Profunctor.Product ()
import Data.Profunctor.Product.TH (makeAdaptorAndInstance)
import qualified Database.PostgreSQL.Simple as PGS
import qualified Opaleye as OE
import RIO

-- | Type synonyms for convenience
type F field = -- | Opaleye type for a non-nullable DB field.
  OE.Field field

type FNull field = -- | Nullable DB field
  OE.FieldNullable field

--------------------
-- Table Setup
--------------------

-- | Polymorphic type for the "user" table. This type describes the "shape" of
-- a record, but not the type of individual record fields. This allows Opaleye
-- map Haskell types to PostgreSQL types by specializing the type parameters.
data UserT key username email bio imageUrl
  = User
      { userKey :: key,
        userUsername :: username,
        userEmail :: email,
        userBio :: bio,
        userImageUrl :: imageUrl
      }
  deriving (Show)

-- | Record that Opaleye uses to write to the "user" table. This record uses
-- native PostgreSQL types. Read- and write-records are different to allow
-- PostgreSQL DB to perform actions upon writing certain fields, like
-- auto-generate a key, or set the insertion date.
type UserW =
  UserT
    (Maybe (F OE.SqlInt8)) -- autogenerated key
    (F OE.SqlText) -- username
    (F OE.SqlText) -- email
    (FNull OE.SqlText) -- optional bio
    (FNull OE.SqlText) -- optional image url

-- | Record that Opaleye reads from the "user" table. This record uses nativ
-- PostreSQL types.
type UserR =
  UserT
    (F OE.SqlInt8) -- key
    (F OE.SqlText) -- username
    (F OE.SqlText) -- email
    (FNull OE.SqlText) -- bio
    (FNull OE.SqlText) -- image url

-- | Typesafe Haskell record to interface with the application. Under the hood,
-- Opaleye converts between this application record and the above PostgreSQL
-- read and write records.
type User =
  UserT
    Int64 -- key
    Text -- username
    Text -- email
    (Maybe Text) -- bio
    (Maybe Text) -- image url

-- | Template Haskell helper to create the mapping function between PostgreSQL
-- records and the Haskell record used below.
$(makeAdaptorAndInstance "pUser" ''UserT)

-- | The actual mapping setup tells Opaleye exactly how to map between the
-- PostgreSQL records and the Haskell record. For each record, the function
-- specifies the name of the table column and the constraints.
userTable :: OE.Table UserW UserR
userTable =
  OE.Table
    "users"
    ( pUser
        User
          { userKey = OE.optional "id",
            userUsername = OE.required "username",
            userEmail = OE.required "email",
            userBio = OE.required "bio",
            userImageUrl = OE.required "image_url"
          }
    )

-- TODO: Create lenses for easier field access if needed.

-- $(makeLensesWith abbreviatedFields ''UserT)

--------------------
-- Queries
--------------------
-- The queries below are written in the typesafe Opaleye query DSL. Opaleye
-- translates them into actual SQL statements that can be executed against the
-- DBMS. The query statements specified below are similar to prepared
-- statements; they need to be executed separately.
-- Queries return Opaleye PostgreSQL "Read" records.

-- | Retrieve all users.
selectUsers :: OE.Select UserR
selectUsers = OE.selectTable userTable

--------------------
-- DB Access
--------------------
-- Functions in the IO Monad that perform the actual database access, given a
-- connection string. These functions use Opaleye primitive that perform the
-- mapping between Haskell records and Opaleye PostgreSQL records.

getAllUsers :: PGS.Connection -> IO [User]
getAllUsers conn = OE.runSelect conn selectUsers
