{-# LANGUAGE Arrows #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE NoImplicitPrelude #-}

-- |
-- Module      :  <File name or $Header$ to be replaced automatically>
-- Description :  Location where events can take place.
-- Copyright   :  (c) 2020, Real-World Haskell Study Group
-- License     :  Apache License 2.0
-- Maintainer  :  real-world-study-group@ugsmail.mailworks.org
-- Stability   :  unstable
-- Lang. Ext.  :  Arrows - Required by Opaleye
--             :  FlexibleInstances - Required by Opaleye
--             :  MultiParamTypeClasses - Required by Opaleye
--             :  TemplateHaskell - Lets Opaleye generate the mapping function
--             :  NoImplicitPrelude - Use RIO instead
--             :  GeneralizedNewtypeDeriving - Simplify newtype usage
--             :  OverloadedStrings - Use Text literals
--
-- Database interface for the "comments" relation, using the Opaleye mapper and
-- typesafe query and data manipulation DSL.
-- See https://github.com/tomjaguarpaw/haskell-opaleye and the (outdated)
-- tutorial here: https://www.haskelltutorials.com/opaleye/index.html
module Persistence.Comments
  ( Comment
  , findAllComments
  )
where

import qualified Control.Arrow                  ( )
import qualified Data.Profunctor.Product        ( )
import           Data.Profunctor.Product.TH     ( makeAdaptorAndInstance )
import qualified Data.Time                     as T
import qualified Database.PostgreSQL.Simple    as PGS
import qualified Opaleye                       as OE
import qualified Persistence.Articles          as PA
import           Persistence.DbConfig           ( schemaName )
import           Persistence.PersistenceUtils
import qualified Persistence.Users             as PU
import           RIO

-----------------------
-- Dedicated Comment ID
-----------------------
newtype CommentIdT a = CommentId {getCommentId :: a}
  deriving (Eq, Show, Display)

$(makeAdaptorAndInstance "pCommentId" ''CommentIdT)

type CommentIdField = CommentIdT (F OE.SqlInt8)

type OptionalCommentIdField = CommentIdT (Maybe (F OE.SqlInt8))

type CommentId = CommentIdT Int64

--------------------
-- Table Setup
--------------------

-- | Polymorphic type for the "comment" table.
data CommentT cKey aKey uKey body timestamp
  = Comment
      { commentKey :: cKey,
        commentArticleFk :: aKey,
        commentAuthorFk :: uKey,
        commentBody :: body,
        commentCreatedAt :: timestamp, -- TODO: Same type? Both optional?
        commentUpdatedAt :: timestamp
      }
  deriving (Show)

-- | Record that Opaleye uses to write to the "comments" table.
type CommentW
  = CommentT
      OptionalCommentIdField -- autogenerated key
      PA.ArticleIdField -- article FK
      PU.UserIdField -- author FK
      (F OE.SqlText) -- body
      (Maybe (F OE.SqlTimestamptz)) -- timestamps

-- | Record that Opaleye reads from the "comments" table.
type CommentR
  = CommentT
      CommentIdField -- comment key
      PA.ArticleIdField -- article FK
      PU.UserIdField -- author FK
      (F OE.SqlText) -- body
      (F OE.SqlTimestamptz) -- timestamps

-- | Typesafe Haskell record to interface with the application. Under the hood,
-- Opaleye converts between this application record and the above PostgreSQL
-- read and write records.
type Comment
  = CommentT CommentId -- comment key
                       PA.ArticleId -- article FK
                                    PU.UserId -- author FK
                                              Text -- body
                                                   T.UTCTime -- timestamps

instance Display Comment where
  display = displayShow

-- | Template Haskell helper to create the mapping function between PostgreSQL
-- records and the Haskell record used below.
$(makeAdaptorAndInstance "pComment" ''CommentT)

-- | The actual mapping setup between the PostgreSQL records and the Haskell
-- record.
commentsTable :: OE.Table CommentW CommentR
commentsTable = OE.tableWithSchema
  schemaName
  "comments"
  (pComment Comment
    { commentKey       = pCommentId (CommentId (OE.tableField "id"))
    , commentArticleFk = PA.pArticleId
                           (PA.ArticleId (OE.tableField "article_fk"))
    , commentAuthorFk  = PU.pUserId (PU.UserId (OE.tableField "author_fk"))
    , commentBody      = OE.tableField "body"
    , commentCreatedAt = OE.tableField "created_at"
    , commentUpdatedAt = OE.tableField "updated_at"
    }
  )

--------------------
-- Queries
--------------------

-- | Retrieve all comments.
selectComments :: OE.Select CommentR
selectComments = OE.selectTable commentsTable

--------------------
-- DB Access
--------------------
-- Functions in the IO Monad that perform the actual database access.

-- | Find all comments stored in the DB and return them.
-- Naming convention: DB retrievals are called "find".
findAllComments :: PGS.ConnectInfo -> IO [Comment]
findAllComments connInfo = do
  conn   <- PGS.connect connInfo
  result <- OE.runSelect conn selectComments
  PGS.close conn
  return result
