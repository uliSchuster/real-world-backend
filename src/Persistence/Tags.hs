{-# LANGUAGE Arrows #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE NoImplicitPrelude #-}

-- |
-- Module      :  <File name or $Header$ to be replaced automatically>
-- Description :  Location where events can take place.
-- Copyright   :  (c) 2020, Real-World Haskell Study Group
-- License     :  Apache License 2.0
-- Maintainer  :  real-world-study-group@ugsmail.mailworks.org
-- Stability   :  unstable
-- Lang. Ext.  :  Arrows - Required by Opaleye
--             :  FlexibleInstances - Required by Opaleye
--             :  MultiParamTypeClasses - Required by Opaleye
--             :  TemplateHaskell - Lets Opaleye generate the mapping function
--             :  NoImplicitPrelude - Use RIO instead
--             :  GeneralizedNewtypeDeriving - Simplify newtype usage
--             :  OverloadedStrings - Use Text literals
--
-- Database interface for the "tags" relation, using the Opaleye mapper and
-- typesafe query and data manipulation DSL.
-- See https://github.com/tomjaguarpaw/haskell-opaleye and the (outdated)
-- tutorial here: https://www.haskelltutorials.com/opaleye/index.html
module Persistence.Tags
  ( TagT (..),
    TagIdT (..),
    TagIdField,
    OptionalTagIdField,
    TagId,
    pTagId,
    Tag,
    findAllTags,
  )
where

import qualified Control.Arrow ()
import qualified Data.Profunctor.Product ()
import Data.Profunctor.Product.TH (makeAdaptorAndInstance)
import qualified Database.PostgreSQL.Simple as PGS
import qualified Opaleye as OE
import Persistence.DbConfig (schemaName)
import Persistence.PersistenceUtils
import RIO

--------------------
-- Dedicated Tag ID
--------------------

newtype TagIdT a = TagId {getTagIdT :: a}
  deriving (Eq, Show, Display)

$(makeAdaptorAndInstance "pTagId" ''TagIdT)

type TagIdField = TagIdT (F OE.SqlInt8)

type OptionalTagIdField = TagIdT (Maybe (F OE.SqlInt8))

type TagId = TagIdT Int64

--------------------
-- Table Setup
--------------------

-- | Polymorphic type for the "tags" table.
data TagT tKey tName
  = TagD
      { tagKey :: tKey,
        tagName :: tName
      }
  deriving (Show)

-- | Record that Opaleye uses to write to the "tags" table.
type TagW =
  TagT
    OptionalTagIdField -- autogenerated key
    (F OE.SqlText) -- tagname

-- | Record that Opaleye reads from the "tags" table.
type TagR =
  TagT
    TagIdField -- tag key
    (F OE.SqlText) -- tagname

-- | Typesafe Haskell record to interface with the application. Under the hood,
-- Opaleye converts between this application record and the above PostgreSQL
-- read and write records.
type Tag =
  TagT
    TagId -- comment key
    Text -- tagname

instance Display Tag where
  display = displayShow

-- | Template Haskell helper to create the mapping function between PostgreSQL
-- records and the Haskell record used below.
$(makeAdaptorAndInstance "pTag" ''TagT)

-- | The actual mapping setup between the PostgreSQL records and the Haskell
-- record.
tagsTable :: OE.Table TagW TagR
tagsTable =
  OE.tableWithSchema
    schemaName
    "tags"
    ( pTag
        TagD
          { tagKey = pTagId (TagId (OE.tableField "id")),
            tagName = OE.tableField "tagname"
          }
    )

--------------------
-- Queries
--------------------

-- | Retrieve all comments.
selectTagss :: OE.Select TagR
selectTagss = OE.selectTable tagsTable

--------------------
-- DB Access
--------------------
-- Functions in the IO Monad that perform the actual database access.

-- | Find all tags stored in the DB and return them.
-- Naming convention: DB retrievals are called "find".
findAllTags :: PGS.ConnectInfo -> IO [Tag]
findAllTags connInfo = do
  conn <- PGS.connect connInfo
  result <- OE.runSelect conn selectTagss
  PGS.close conn
  return result
