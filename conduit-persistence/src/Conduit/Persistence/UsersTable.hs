{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE NoImplicitPrelude #-}

-- |
-- Module      :  <File name or $Header$ to be replaced automatically>
-- Description :  Location where events can take place.
-- Copyright   :  (c) 2020, Real-World Haskell Study Group
-- License     :  Apache License 2.0
-- Maintainer  :  real-world-study-group@ugsmail.mailworks.org
-- Stability   :  unstable
-- Lang. Ext.  :  FlexibleInstances - For Opaleye table types
--             :  MultiParamTypeClasses - For Opaleye table types
--             :  TemplateHaskell - Lets Opaleye generate the mapping function
--             :  NoImplicitPrelude - Use RIO instead
--             :  GeneralizedNewtypeDeriving - Simplify newtype usage
--             :  OverloadedStrings - Use Text literals
--
-- Database interface for the "user" relation, using the Opaleye mapper and
-- typesafe query and data manipulation DSL.
-- See https://github.com/tomjaguarpaw/haskell-opaleye and the (outdated)
-- tutorial here: https://www.haskelltutorials.com/opaleye/index.html
module Conduit.Persistence.UsersTable
  ( UserIdT(..)
  , UserIdField
  , OptionalUserIdField
  , UserId
  , pUserId
  , UserT(..)
  , UserR
  , User
  , allUsersQ
  )
where

import qualified Data.Profunctor.Product        ( )
import           Data.Profunctor.Product.TH     ( makeAdaptorAndInstance )
import qualified Opaleye                       as OE
import           Conduit.Persistence.DbConfig   ( schemaName )
import           Conduit.Persistence.PersistenceUtils
import           RIO

--------------------
-- Dedicated User ID
--------------------

newtype UserIdT a = UserId {getUserId :: a}
  deriving (Eq, Show, Display)

$(makeAdaptorAndInstance "pUserId" ''UserIdT)

type UserIdField = UserIdT (F OE.SqlInt8)

type OptionalUserIdField = UserIdT (Maybe (F OE.SqlInt8))

type UserId = UserIdT Int64

--------------------
-- Table Setup
--------------------

-- | Polymorphic type for the "user" table. This type describes the "shape" of
-- a record, but not the type of individual record fields. This allows Opaleye
-- map Haskell types to PostgreSQL types by specializing the type parameters.
data UserT key username email bio imageUrl pwdHash salt
  = User
      { userKey :: !key,
        userUsername :: !username,
        userEmail :: !email,
        userBio :: !bio,
        userImageUrl :: !imageUrl,
        userPwdHash :: !pwdHash,
        userSalt :: !salt
      }
  deriving (Show)

-- | Record that Opaleye uses to write to the "user" table. This record uses
-- native PostgreSQL types. Read- and write-records are different to allow
-- PostgreSQL DB to perform actions upon writing certain fields, like
-- auto-generate a key, or set the insertion date.
type UserW
  = UserT
      OptionalUserIdField -- autogenerated key
      (F OE.SqlText) -- username
      (F OE.SqlText) -- email
      (FNull OE.SqlText) -- optional bio
      (FNull OE.SqlText) -- optional image url
      (F OE.SqlText) -- password hash
      (F OE.SqlText) -- password salt

-- | Record that Opaleye reads from the "user" table. This record uses nativ
-- PostreSQL types.
type UserR
  = UserT
      UserIdField -- key
      (F OE.SqlText) -- username
      (F OE.SqlText) -- email
      (FNull OE.SqlText) -- bio
      (FNull OE.SqlText) -- image url
      (F OE.SqlText) -- password hash
      (F OE.SqlText) -- password salt


-- | Typesafe Haskell record to interface with the application. Under the hood,
-- Opaleye converts between this application record and the above PostgreSQL
-- read and write records.
type User
  = UserT UserId -- key
                 Text -- username
                      Text -- email
                           (Maybe Text) -- bio
                                        (Maybe Text) -- image url
                                                     Text -- pwdHash
                                                          Text -- Salt

instance Display User where
  display = displayShow

-- | Template Haskell helper to create the mapping function between PostgreSQL
-- records and the Haskell record used below.
$(makeAdaptorAndInstance "pUser" ''UserT)

-- | The actual mapping setup tells Opaleye exactly how to map between the
-- PostgreSQL records and the Haskell record. For each record, the function
-- specifies the name of the table column and the constraints.
userTable :: OE.Table UserW UserR
userTable = OE.tableWithSchema
  schemaName
  "users"
  (pUser User { userKey      = pUserId (UserId (OE.tableField "id"))
              , userUsername = OE.tableField "username"
              , userEmail    = OE.tableField "email"
              , userBio      = OE.tableField "bio"
              , userImageUrl = OE.tableField "image_url"
              , userPwdHash  = OE.tableField "password_hash"
              , userSalt     = OE.tableField "salt"
              }
  )

-- TODO: Create lenses for easier field access if needed.
-- $(makeLensesWith abbreviatedFields ''UserT)

--------------------
-- Basic Query
--------------------

-- | Retrieve all users.
allUsersQ :: OE.Select UserR
allUsersQ = OE.selectTable userTable
